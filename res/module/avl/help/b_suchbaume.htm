<html>
<head>
	<title>Suchbäume</title>
</head>

<body topmargin="30" leftmargin="30">

<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="600" id="AutoNumber1">
  <tr>
    <td width="600">

    <h2>Suchbäume</h2>
    <p align="justify">Suchbäume sind binäre Bäume (jeder Knoten hat höchstens 2 Kinder) mit der Eigenschaft:
	Für jeden Knoten gilt: alle Schlüssel im rechten Teilbaum sind größer als der eigene Schlüssel und
	alle Schlüssel im linken Teilbaum sind kleiner. Diese Eigenschaft wird hier immer Suchbaumeigenschaft
	genannt.</p>
   	<p align="center">
   	<img src="pics/bsp_suchbaum.png" width="203" height="233">
    
	<p align="justify">An dieser Stelle noch eine Bemerkung zu den Schlüsseln: Die Schlüssel können 
	Elemente einer beliebigen Menge sein, unter der Bedingung, dass auf dieser Menge eine Ordnungsrelation definiert
	ist. Die Ordnungsrelation wird offensichtlich für die Suchbaumeigenschaft benötigt, da dort die
	Begriffe "kleiner" und "größer" vorkommen. Eine häufig verwendete Menge sind die natürlichen
	Zahlen mit ihrer normalen Ordnungsrelation <=. Alle Operationen auf Suchbäumen kann man sich
	also anhand der natürlichen Zahlen vorstellen. Aus der Suchbaumeigenschaft kann man sich leicht 
	rekursive Algorithmen für das Einfügen und Suchen in einem Suchbaum herleiten:</p>
	<p>
	<b>Algorithmus 1</b><i> (Suchen eines Schlüssels s in einem Suchbaum) </i>
	<ol type="a">
		<li><i>Falls Teilbaum leer, dann Schlüssel nicht im Baum vorhanden</i></li>
		<li><i>Falls s gleich dem Schlüssel des aktuellen Knoten, dann Suche erfolgreich.</i></li>
		<li><i>Falls s größer als Schlüssel des aktuellen Knotens, dann suche (rekursiv) s im rechten Teilbaum.</i></li>
		<li><i>Falls s kleiner als Schlüssel des aktuellen Knotens, dann suche (rekursiv) s im linken Teilbaum.</i></li>
	</ol>
	<p>
	<b>Algorithmus 2</b><i>(Einfügen eines Schlüssels s in einen Suchbaum)</i>
	<ol type="a">
		<li><i>Falls Teilbaum leer, dann neuen Schlüssel hier einfügen.</i></li>
		<li><i>Falls s gleich dem Schlüssel des aktuellen Knotens, dann Schlüssel bereits vorhanden, Einfügen
				nicht nötig.</i></li>
		<li><i>Falls s größer als Schlüssel des aktuellen Knotens, dann füge (rekursiv) s in den rechten
				Teilbaum ein.</i></li>
		<li><i>Falls s kleiner als Schlüssel des aktuellen Knotens, dann füge (rekursiv) s in den linken Teilbaum
				ein.</i></li>
	</ol>
	<p align="justify">Mit Algorithmus 2 ergibt sich folgende Eigenschaft der Struktur von Suchbäumen: im Gegensatz
	zur sortierten Liste hängt die Struktur eines Baumes davon ab, in welcher Reihenfolge die Elemente
	eingefügt werden. So erhält man verschieden Bäume, wenn man 1, 2, 3, 4 in dieser Reihenfolge und
	in der Reihenfolge 3, 2, 4, 1 einfügt. </p>
	<p align="center">
	<img src="pics/12345.png" width="400">
	<p align="justify">
	Im ersten Fall erhält man einen Suchbaum, der zur linearen Liste entartet ist. Das ist nicht nur in
	dieser speziellen Reihenfolge so, es gibt viele Möglichkeiten einen entarteten Baum zu erzeugen.
	Der Algorithmus hat also zwei Nachteile: zum einen kann der Suchaufwand linear zur Anzahl der
	Knoten im Baum sein, was keine Verbesserung zur linearen Liste darstellt; zum andern hängt die
	Güte des Verfahrens von der Eingabefolge ab. Der Vorteil von Suchbäumen wird klar, wenn man
	einen ”vollen“ Baum betrachtet, d.h. jeder Knoten hat entweder kein Kind (Blattknoten) oder
	zwei Kinder (innerer Knoten). Dann hat sowohl das Suchen (unabhängig davon, ob der Schlüssel
	im Baum vorhanden ist) als auch das Einfügen eine Komplexität von O(log n).</p>
	<p align="center">
	<img src="pics/vollerbaum.png" width="450">

	<p align="justify">Es gibt einige Algorithmen, wie man den Einfügealgorithmus modifizieren kann, um die entarteten
	Fälle zu vermeiden und immer einen nahezu vollen Baum hat. Einen davon, den Algorithmus nach
	Adelson-Velskij und Landis (AVL), werden wir später betrachten.</p>
	
	<p align="justify">Doch zunächst wollen wir noch eine weitere wichtige Operation auf Suchbäumen untersuchen: das
	Löschen. Leider ist es nicht ganz so einfach wie Suche und Einfügen.<br>
	Zuerst muss der zu löschende Schlüssel gesucht werden. Ist der betreffende Knoten ein Blatt, kann
	er einfach entfernt werden. Hat der zu löschende Knoten nur ein Kind, kann er durch dieses ersetzt
	werden. Der schwierige Fall ist, wenn er zwei Kinder hat. Damit die Suchbaumeigenschaft erhalten
	bleibt, muss man ihn durch den nächst größeren Schlüssel ersetzen. Der nächst größere Schlüssel
	befindet sich offensichtlich im rechten Teilbaum.</p>
	<p align="center">
	<img src="pics/remove.png" width="350">
	
	<p align="justify">Nach dem Ersetzen bleibt die Suchbaumeigenschaft erhalten, weil alle Schlüssel aus dem linken
	Teilbaum ohnehin kleiner sind als die aus dem rechten. Außerdem sind auch alle Schlüssel aus
	dem rechten Teilbaum größer, sonst wäre es nicht der nächst größere Schlüssel 
    gewesen. Aus diesen Überlegungen erhält man folgende verbale Beschreibung des Löschen-Algorithmus:</p>
	<b>Algorithmus 3</b><i> (Löschen eines Schlüssels s aus einem Suchbaum) </i>
	<ol>
		<li><i>Suche s nach Algorithmus 1. Falls s nicht im Baum enthalten, terminiert der Algorithmus.</i></li>
		<li><ol type="a">
				<li><i>Ist der zu löschende Knoten ein Blatt, dann entferne ihn einfach aus dem Baum.</i></li>
				<li><i>Hat der zu löschende Knoten nur ein Kind, dann ersetze ihn durch dieses.</i></li>
				<li><i>Sonst suche den kleinsten Schlüssel im rechten Teilbaum: Gehe zum rechten Kind und
						dann immer zum linken Teilbaum, solange dieser nicht leer ist. Ersetze den zu löschenden
						Schlüssel durch den des so gefundenen Knotens. Ersetze den gefundenen Knoten durch sein
						rechtes Kind.</i></li>
			</ol>		
	</ol>
	
	<p align="justify">Man kann anstelle des nächst größeren Schlüssels genausogut den nächstkleineren nehmen, der
	Algorithmus funktioniert trotzdem. Zur Komplexität ist zu sagen, dass der Algorithmus maximal
	h Vergleiche macht, wobei h die Höhe des Baumes ist. Auch hier ist also die Komplexität abhängig
	von der Struktur des Baumes.</p>
	
	
	
	
	
	<p>&nbsp
	
	
    </td>
  </tr>
</table>
	
</body>

</html>