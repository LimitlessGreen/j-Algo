\newcommand{\code}[1]{\lstinline$#1$}

\section{Implementieren eines neuen Moduls}
Hier sollen nur die technischen Schritte angegeben sein, die nötig sind, ein neues Modul für \jalgo korrekt und vollständig aufzusetzen und in das Hauptprogramm zu integrieren. Es wird vorausgesetzt, dass der Entwickler selbst ein Konzept seines Moduls entwickelt, insbesondere, was Details der Visualisierung betrifft.

Es folgen fünf Abschnitte. Im ersten wird der Teil erklärt, der für das Implementieren eines neuen Moduls minimal notwendig ist. Der zweite Abschnitt enthält Erklärungen zur Funktionsweise der Pluginstruktur von \jalgo, und was der Entwickler für korrekte Erkennung des Moduls zu beachten hat. Der dritte Abschnitt zeigt, wie die Ressourcen des zu implementierenden Moduls organisiert sein sollten. Der vierte Abschnitt erklärt, wie die Dateien der Online-Hilfe für das Modul zu organisieren sind und der fünfte Abschnitt schließlich zeigt die hauptprogrammseitige Schnittstelle zwischen Modul und Hauptprogramm. Im folgenden wird abkürzend für "`Das zu implementierende Modul"' nur "`Das Modul"' geschrieben.

\subsection{Grundimplementierung}
Der Code für das Modul wird im Paket \verb|org.jalgo.module.|\textsc{<Modulkürzel>} abgelegt. Das Modulkürzel sollte aussagekräftig, jedoch relativ kurz gehalten sein. Es wird später im Code oft benötigt, wenn es um Ressourcen-Zugriffe geht.\\
Eine schlechte Wahl wären also zum Beispiel \verb|dijkstrasShortestPathAlgorithm| oder vielleicht \verb|syntaxDiagramsAndEBNF|.

Es gibt zwei Schnittstellen, um das Hauptprogramm mit einem Modul zu vernetzen. Die erste, modulseitige, Schnittstelle besteht aus zwei Klassen. Jedes Modul muss eine Verbindungseinheit und eine Informationseinheit anbieten. Die Verbindungseinheit muss abgeleitet sein von \verb|org.jalgo.main.AbstractModuleConnector|. Hier sind Methoden zu implementieren, die die Interaktion des Moduls mit dem Hauptprogramm spezifizieren. Für Details dazu sollte die API-Dokumentation von \jalgo konsultiert werden. Nachfolgend ist die Schnittstelle von \verb|AbstractModuleConnector| abgebildet.\\[0.25cm]
\textbf{Achtung!} Die Verbindungseinheit muss sich an eine Namenskonvention halten: Paket und Name der Klasse muss \verb|org.jalgo.module.|\textsc{<Modulkürzel>}\verb|.ModuleConnector| lauten. Dies ist ein notwendiger Teil der Pluginstruktur von \jalgo. Für Details dazu lesen Sie bitte den nächsten Abschnitt.
\newpage
\begin{verbatim}
public abstract class AbstractModuleConnector {
    public abstract void init();
    public abstract void run();
    public abstract void setDataFromFile(ByteArrayInputStream data);
    public abstract ByteArrayOutputStream getDataForFile();
    public abstract void print();

    public boolean close();

    public final IModuleInfo getModuleInfo();
    public enum SaveStatus {
        NOTHING_TO_SAVE,
        NO_CHANGES,
        CHANGES_TO_SAVE
    }
    public final SaveStatus getSaveStatus();
    public final void setSaveStatus(SaveStatus status);
    public final void setSavingBlocked(boolean blocked);
    public final boolean isSavingBlocked();
    public final String getOpenFileName();
    public final void setOpenFileName(String filename);
}
\end{verbatim}

Die Informationseinheit ist dazu da, Informationen über das Modul bereitzustellen, die dem Benutzer entsprechend aufbereitet dargeboten werden, wenn er ein Modul zur Benutzung auswählen will. Sie muss das Interface \verb|org.jalgo.main.IModuleInfo| implementieren. Für Details dazu sei hier wieder auf die API-Dokumentation von \jalgo verwiesen. Nachfolgend ist die Schnittstelle von \verb|IModuleInfo| abgebildet.
\begin{verbatim}
public interface IModuleInfo {
    public String getName();
    public String getVersion();
    public String getAuthor();
    public String getDescription();
    public URL getLogoURL();
    public String getLicense();
    public URL getHelpSetURL();
}
\end{verbatim}
\textbf{Achtung!} Die Informationseinheit muss sich an eine Namenskonvention halten: Name und Paket der Klasse muss \verb|org.jalgo.module.|\textsc{<Modulkürzel>}\verb|.ModuleInfo| lauten. Dies ist notwendiger Teil der Pluginstruktur von \jalgo.\\
Weiterhin hat die Informationseinheit das \textbf{Singleton}-Entwurfsmuster zu implementieren mit der Zugriffsmethode
\verb|public static IModuleInfo getInstance();|\\
Als Klassenmethode kann diese nicht in das Interface \verb|IModuleInfo| aufgenommen werden. Es sei jedoch ausdrücklich darauf hingewiesen, dass das Fehlen dieser Methode dazu führt, dass das Modul nicht korrekt erkannt wird und dass Laufzeitfehler beim Starten des Programmes auftreten.

Als Beispielcode ist ein minimalistisches Modul implementiert namens \verb|testModule|. Es ist ein korrekt implementiertes Modul, jedoch hat es keinerlei Funktionalität. Der Entwickler kann den Code bei Bedarf als Skelett zum Aufsetzen eines neuen Moduls nehmen. Zum aktuellen Zeitpunkt existieren für \jalgo 2 Module: \textbf{AVL-Bäume} und \textbf{Dijkstra}. Es sei dem Entwickler freigestellt, diese als Anleihe zu nehmen.\\[0.5cm]
Mit diesen beiden Klassen ist die modulseitige Schnittstelle fertiggestellt. Damit das Modul als solches auch vom Hauptprogramm erkannt wird, ist noch ein Schritt notwendig.

\subsection{Pluginstruktur von \jalgo}
An dieser Stelle scheint es angebracht, kurz die Pluginstruktur von \jalgo zu erläutern. In der Distribution wird das Hauptprogramm in ein JAR-Archiv verpackt. Es muss unabhängig von den Modulen sein. Daher wird auch jedes Modul in ein eigenes JAR-Archiv verpackt mit allem, was zu diesem Modul gehört: Code und Ressourcendateien. Dies garantiert, dass bei Erscheinen eines neuen Modules nur das entsprechende JAR-Archiv vom Benutzer heruntergeladen werden muss.\\[0.25cm]
\textbf{Achtung!} Die JAR-Archive für die Module müssen als Namen das Modulkürzel tragen und im Ordner \verb|runtime/modules| liegen. Nur so kann das Modul vom Hauptprogramm erkannt werden.\\[0.25cm]
Während der Laufzeit wird zum Start des Hauptprogramms der Ordner \verb|runtime/modules| nach JAR-Archiven durchsucht. Dabei wird der Name des Archives als Paketname angenommen, und es wird in jedem Archiv nach den beiden Verbindungsklassen (siehe oben) gesucht:\\
\verb|org.jalgo.module.|\textsc{<Archivname>}\verb|.ModuleConnector| und\\
\verb|org.jalgo.module.|\textsc{<Archivname>}\verb|.ModuleInfo|\\
Sind diese korrekt implementiert, wird das Modul in die Liste der installierten Module aufgenommen und kann vom Benutzer ausgewählt werden.

Der Entwickler hat also nun noch eine leere Datei mit dem Namen \textsc{<Modulkürzel>}\verb|.jar| im Ordner \verb|runtime/modules| zu erstellen. Wird \jalgo aus der Entwicklungsumgebung ge\-startet, kann das Modul nun aufgerufen werden.
\newpage

\subsection{Organisation der Ressourcen}
Sicher soll das Modul irgendwelche Ressourcendateien halten, wie zum Beispiel Icons oder ausgelagerte Algorithmentexte.

Da, wie erwähnt, zur Laufzeit das Modul in einem JAR-Archiv vorliegt, kann auf die Ressourcen nur über den Klassenlader zugegriffen werden, indem die Methoden\\ \verb|getClass().getResource(String)| (liefert eine URL) oder\\ \verb|getClass().getResourceAsStream(String)| (liefert einen InputStream)\\
verwendet werden. Es erweist sich als vorteilhaft, wenn die Pfade zu den Ressourcendateien nicht direkt im Code verankert werden, sondern in einer externen Textdatei abgelegt werden. Um einen einfachen Ressourcenzugriff zu ermöglichen, bietet das Hauptprogramm mit der Klasse \verb|org.jalgo.main.util.Messages| die Methode\\
\verb|getResourceURL(String bundleKey, String key)|\\
an, welche direkt die URL einer Ressource zurückgibt. Der erste Parameter ist der Schlüssel, mit welchem das Ressourcenpaket ausgewählt wird, aus dem der Pfad zu entnehmen ist. Dies ist wieder das Modulkürzel, also der Hauptpaketname, wenn moduleigene Ressourcen geladen werden sollen, und \verb|main|, wenn Ressourcen des Hauptprogramms, z.B. Standard-Icons verwendet werden sollen. Der zweite Parameter ist der Schlüssel der Ressource. Dafür ist im Hauptpaket des Moduls eine Textdatei zu erstellen, in welcher Ressourcenpfade zu Schlüsseln zugeordnet werden. Es sei als Beispiel auf die existierenden Dateien von Hauptprogramm und den bestehenden Modulen verwiesen.\\[0.25cm]
\textbf{Achtung!} Die Textdatei mit den Ressourcenpfaden muss einer Namenskonvention folgen: Sie hat den Titel \verb|res.properties| zu tragen und muss im Hauptpaket des Moduls liegen. Anderenfalls wird sie von der Klasse \verb|Messages| nicht gefunden.\\[0.25cm]
Die Ressourcendateien selbst werden im Ordner \verb|res/module/|\textsc{Modulkürzel} abgelegt. Wird unter Eclipse programmiert, ist dieser Ordner unter "`Projekteinstellungen"'->"`Libraries"'->"`Add Class Folder..."' hinzuzufügen, damit die Ressourcen in der Entwicklungsumgebung freigegeben sind.\\
Um Namenskonflikten unter den Ressourcendateien vorzubeugen (letzlich liegen alle Ressourcenpfade hinter \verb|res/main/| und \verb|res/module/|\textsc{<Modulkürzel>}\verb|/| auf dem Klassenpfad), empfiehlt es sich, im angelegten Ressourcenordner eine angemessene Struktur zu entwickeln, so zum Beispiel einen Unterordner \textsc{<Modulkürzel>}\verb|_pix| für Bilddateien. Jetzt kann auch ein Dateiname wie \verb|icon.gif| ohne Probleme verwendet werden.\vspace{0.5cm}

\jalgo ist ein Programm, welches mehrere Sprachen unterstützt. Zum aktuellen Zeitpunkt sind sämtliche Programmteile in Deutsch und Englisch verfügbar. Dem Entwickler wird nahegelegt, auch das neue Modul in diesen Sprachen zu veröffentlichen. Dazu ist es notwendig, alle Zeichenketten, die dem Benutzer dargeboten werden sollen, in externen Textdateien zu speichern. Auch für den einfachen Zugriff auf diese Zeichenketten bietet die Klasse \verb|org.jalgo.main.util.Messages| eine Methode an:\\
\verb|getString(String bundleKey, String messageKey)|\\
Die Verwendung dieser Methode erfolgt analog zu der oben erwähnten Methode für die Ressourcen.\newpage
\textbf{Achtung!} Die Textdatei mit den ausgelagerten Zeichenketten muss einer Namenskonvention folgen: Auch sie hat die Endung \verb|.properties| zu tragen. Der Name der Datei ist einfach das Kürzel der Sprache, für welche sie Zeichenketten enthält. Für deutsch also \verb|de.properties|, für englisch \verb|en.properties|. Auch diese Textdateien haben im Hauptpaket des Moduls zu liegen.\\[0.25cm]
Liegen die Textdateien korrekt vor, so wird vom Hauptprogramm automatisch auf die eingestellte Sprache umgestellt. Der Modulentwickler muss hierzu nichts mehr beachten.\\
Auch hier wieder sei als Beispiel auf die existierenden Dateien von Hauptprogramm und Modulen verwiesen.\vspace{0.5cm}

Letzlich sei noch erwähnt, dass jedes Modul die Möglichkeit hat, persistente Benutzereinstellungen anzubieten. Will der Modulentwickler solche Einstellungen einbauen, so muss eine Textdatei mit Zuordnungen zwischen Schlüsseln und Werten angelegt werden. Es sind hier alle Einstellmöglichkeiten als Schlüssel zu erwähnen; die zugeordneten Werte sind jeweils die Default-Werte für die entsprechenden Einstellungen.\\[0.25cm]
\textbf{Achtung!} Die Textdatei mit den Default-Einstellungen muss einer Namenskonvention folgen: Sie muss den Namen \textsc{<Modulkürzel>}\verb|.prefs| tragen und im Ressourcenverzeichnis des Moduls (\verb|res/|\textsc{<Modulkürzel>}\verb|/|) liegen. Außerdem muss ein Schlüssel namens "`Version"' in der Datei stehen, dessen Wert die Version der Einstellungsdatei angibt. Wird in einer späteren Version etwas am Bestand der Schlüssel geändert, gewährleistet der geänderte Wert von "`Version"', dass beim Benutzer die Einstellungsdatei neu erstellt wird und an die neuen Einstellungen anpasst wird.\\[0.25cm]
Es wird als Beispiel auf die Dateien \verb|main.prefs| des Hauptprogramms und \verb|avl.prefs| des Moduls AVL-Bäume verwiesen.\\
Zugegriffen wird auf die persistenten Einstellungen über die Klasse\\ \verb|org.jalgo.main.util.Settings|\\
Für Details ist die API-Dokumentation von \jalgo zu konsultieren. Nachfolgend ist der relevante Teil von \verb|Settings| abgebildet:
\begin{verbatim}
public class Settings {

    public static boolean getBoolean(String resourceKey, String settingKey);
    public static void setBoolean(String resourceKey, String key,
        boolean value);
    public static String getString(String resourceKey, String key);
    public static void setString(String resourceKey, String key,
        String value);
}
\end{verbatim}
Wie schon beim Zugriff auf Ressourcenpfade und ausgelagerte Zeichenketten gibt der erste Parameter jeder Methode hier an, in welcher Einstellungsdatei die Einstellmöglichkeit gesucht werden soll. Dies ist für modulspezifische Einstellungen wieder das Modulkürzel. Es ist aber auch möglich, an die Einstellungen des Hauptprogramms zu gelangen mittels des \verb|resourceKey|s \verb|main|.
\newpage

\subsection{Organisation der Hilfe-Dateien}
Dem Entwickler angeraten, ebenfalls eine Online-Hilfe zu seinem Modul zu erstellen. Die Online-Hilfe von \jalgo nutzt die Technologie von \textbf{JavaHelp}. Es folgt eine kurze Einführung in dieses System.\\
\dots\\
TODO: Matthias, du bist dran, denk auch daran, dass Du mir noch die Änderungen für das Gewährleisten der Kontextsensitivität schilderst.

\subsection{Schnittstelle zum Hauptprogramm}
Die zweite erwähnte Schnittstelle ist die auf Seiten des Hauptprogramms, namentlich die Klasse \verb|org.jalgo.main.gui.JAlgoGUIConnector|. Der Entwickler hat hier nichts zu implementieren, jedoch hat er Kenntnis von dieser Schnittstelle zu haben. Hierüber laufen alle Anfragen, die das Modul an die graphische Oberfläche des Hauptprogramms richtet. Für Details dazu sei auf die API-Dokumentation von \jalgo verwiesen. Nachfolgend ist die Schnittstelle von \verb|JAlgoGUIConnector| abgebildet. Gerade die letzten 3 Methoden sind interessant, um an die moduleigenen GUI-Komponenten zu gelangen.
\begin{verbatim}
public class JAlgoGUIConnector {

    public static JAlgoGUIConnector getInstance();

    public void saveStatusChanged(AbstractModuleConnector moduleInstance);
    public void showErrorMessage(String msg);
    public void showWarningMessage(String msg);
    public void showInfoMessage(String msg);
    public int showConfirmDialog(String question, int optionType);
    public void setStatusMessage(String msg);
    public String showOpenDialog(boolean openAsJAlgoFile,
                                 boolean useCurrentModuleInstance);
    public AbstractModuleConnector newModuleInstanceByName(String moduleName);

    public JComponent getModuleComponent(AbstractModuleConnector module);
    public JMenu getModuleMenu(AbstractModuleConnector module);
    public JToolBar getModuleToolbar(AbstractModuleConnector module);
}
\end{verbatim}
Diese Klasse implementiert das \textbf{Singleton}-Entwurfsmuster. Somit kommt man über die Zugriffsmethode \verb|getInstance()| an die Instanz.
\newpage