\documentclass[12pt]{scrartcl}
\usepackage{a4wide, listings, url}
\usepackage[latin1]{inputenc}
 
\title{J-Algo\\Module Programmers Manual}
\author{Stephan Creutz \and Michael Pradel \and Alexander Claus}
\date{\today}

\newcommand{\code}[1]{\lstinline$#1$}

\begin{document}
\maketitle
\lstset{basicstyle=\small\sffamily,language=Java,showstringspaces=false,tabsize=4,columns=fullflexible,captionpos=b}
\section{Introduction to jAlgo}
J-Algo was developed to provide multiple module support. Each module should
cover one topic (e.g. tree algorithms or EBNF). For this reason we created a
simple interface. This interface is described in the sections below.\\
The software is using Swing (see section \ref{seealso}), thus you have to use
it too.

\section{Implementing a module}

To implement a new J-Algo module, create a directory with your modules name in
\url{/source/org/jalgo/module}. This directory has to contain at least two classes:
\mbox{ModuleConnector.java} implementing the interface IModuleConnector and
\mbox{ModuleInfo.java} implementing the interface IModuleInfo.\\

In order to help you to write a new module, there is an minimalistic module called
testModule. It is a correctly implemented J-Algo module, but does nothing. You
can use it as a skeleton for any new module.

\subsection{IModuleConnector}
This abstract class establishes a connection to the main program.
You have to implement the abstract methods listed below:
\newpage

\begin{lstlisting}[frame=single,caption={IModuleConnector}]
public abstract class AbstractModuleConnector {

	private SaveStatus saveStatus;
	private boolean savingBlocked;
	private String openFileName;

	/**
	 * Constructs an <code>AbstractModuleConnector</code>.
	 */
	public AbstractModuleConnector() {
		saveStatus = SaveStatus.NOTHING_TO_SAVE;
	}

	/**
	 * Modules have to override this method to initialize their GUI.
	 */
	public abstract void init();

	/**
	 * After the module has been initialized using the constructor (and maybe
	 * some methods), this method will be invoked by the main program. It should
	 * contain the code to start the module. This method should return soon.
	 */
	public abstract void run();

	/**
	 * If the user opens a file saved with the specific module, this method is
	 * called with an input stream backed by the file. So the module programmer
	 * has to care, how to read from the file.
	 * 
	 * @param data an input stream with the file content in the format saved by
	 *            the module
	 */
	public abstract void setDataFromFile(ByteArrayInputStream data);

	/**
	 * If user wants to save the current module data, this method is called. The
	 * module programmer has to prepare the interesting data and to provide it
	 * as output stream in a format, which can be deserialized too!
	 * 
	 * @return an output stream with the interesting data of the module
	 */
	public abstract ByteArrayOutputStream getDataForFile();

	/**
	 * Printing is currently not supported, this method is only present for
	 * compatibility.
	 */
	public abstract void print();

	/**
	 * This method is called, when module or program are intended to be closed.
	 * Here final operations can be performed, before closing the module, or, if
	 * the module is currently not ready to be closed, this method can return
	 * <code>false</code>. When this method returns <code>true</code>, the
	 * user will be asked for saving his work (if there is something to save).
	 * Otherwise the closing of the module / program is ignored.
	 * 
	 * @return <code>true</code>, if module is ready to be closed,
	 *         <code>false</code> otherwise
	 */
	public boolean close() {
		return true;
	}

	/**
	 * Retrieves the singleton instance of the <code>IModuleInfo</code>
	 * corresponding to this module.
	 * 
	 * @return the corresponding <code>IModuleInfo</code>
	 * 
	 * @see IModuleInfo
	 */
	public final IModuleInfo getModuleInfo() {
		try {
			return (IModuleInfo)Class.forName(
				getClass().getPackage().getName() + ".ModuleInfo").getMethod(
				"getInstance", new Class[] {}).invoke(null, new Object[] {});
		}
		catch (Exception ex) {
			ex.printStackTrace();
		}
		return null;
	}

	/**
	 * The enum type <code>SaveStatus</code> is used by modules to indicate if
	 * module content has changed or not. This status is evaluated to set the
	 * enabled status of the save buttons in the main program.
	 */
	public enum SaveStatus {
		/** Indicates, that there is no file open or nothing to save */
		NOTHING_TO_SAVE,
		/** Indicates, that the current file was saved recently */
		NO_CHANGES,
		/** Indicates, that the current file is 'dirty' and has to be saved */
		CHANGES_TO_SAVE
	}

	/**
	 * This method retrieves the save status of the module. This method is
	 * necessary for correctly working of the enabled button status of the save
	 * buttons and several features.
	 * 
	 * @return one of the {@link SaveStatus} enum constants:
	 *         <ul>
	 *         <li><code>NOTHING_TO_SAVE</code></li> - if there is no file
	 *         open
	 *         <li><code>NO_CHANGES</code></li> - if the open file was saved
	 *         recently
	 *         <li><code>CHANGES_TO_SAVE</code></li> - if there are changes
	 *         to save
	 *         </ul>
	 */
	public final SaveStatus getSaveStatus() {
		return saveStatus;
	}

	/**
	 * This method is called from main program during a save action. Furthermore
	 * this method can be used by the module to set the save status centrally.
	 * 
	 * @param status the new save status
	 * 
	 * @see #getSaveStatus()
	 * @see SaveStatus
	 */
	public final void setSaveStatus(SaveStatus status) {
		saveStatus = status;
		if (status == SaveStatus.NOTHING_TO_SAVE) setOpenFileName(null);
		else if (status == SaveStatus.CHANGES_TO_SAVE && openFileName == null)
			setOpenFileName("");
		JAlgoGUIConnector.getInstance().saveStatusChanged(this);
	}

	/**
	 * This method can be called, if the save buttons should be disabled for a
	 * while, e.g. during a running algorithm. So can be guaranteed, that only
	 * consistent states of module contents can be saved. Ensure to deblock the
	 * save buttons !!!
	 * 
	 * @param blocked <code>true</code>, if the save buttons should be
	 *            blocked, <code>false</code> otherwise
	 * 
	 * @see #isSavingBlocked()
	 */
	public final void setSavingBlocked(boolean blocked) {
		savingBlocked = blocked;
		JAlgoGUIConnector.getInstance().saveStatusChanged(this);
	}

	/**
	 * Retrieves, if saving mechanism is blocked or not, e.g. during a running
	 * algorithm.
	 * 
	 * @return <code>true</code> if saving mechanism is blocked,
	 *         <code>false</code> otherwise
	 */
	public final boolean isSavingBlocked() {
		return savingBlocked;
	}

	/**
	 * Retrieves the file name of the currently opened file. This file name is
	 * shown on the title bar of the main program.
	 * 
	 * @return the file name of the currently opened file
	 */
	public final String getOpenFileName() {
		return openFileName;
	}

	/**
	 * Sets the file name of the currently opened file. This method is called by
	 * the main program, when a file is opened or when a file is saved with a
	 * new name (save as).
	 * 
	 * @param filename the file name of the currently opened file.
	 */
	public final void setOpenFileName(String filename) {
		openFileName = filename;
	}
}
\end{lstlisting}

\subsection{ModuleConnector from testModule}
Here is a concrete example for a class implementing the abstract class \code{AbstractModuleConnector}.

% TODO: wie wird print() umgesetzt, momentan wird dies am interface vorbei gemacht
\begin{lstlisting}[frame=single,caption={IModuleInfo interface}]
public class ModuleConnector
extends AbstractModuleConnector {

	@Override
	public void init() {
		JComponent contentPane =
			JAlgoGUIConnector.getInstance().getModuleComponent(this);
		JLabel helloJAlgo = new JLabel(
			"Hello j-Algo!",
			new ImageIcon(Messages.getResourceURL("main", "ui.Logo")),
			SwingConstants.CENTER);
		contentPane.add(helloJAlgo, BorderLayout.CENTER);

		JMenu menu = JAlgoGUIConnector.getInstance().getModuleMenu(this);
		JMenuItem item = new JMenuItem("a menu item");
		menu.add(item);

		JToolBar toolbar =
			JAlgoGUIConnector.getInstance().getModuleToolbar(this);
		JToolbarButton button = new JToolbarButton(
			new ImageIcon(Messages.getResourceURL("main", "ui.Logo_small")),
			"a tooltip",
			"");
		toolbar.add(button);
	}

	@Override
	public void run() {
		System.out.println("testModule is running");
	}

	@Override
	public void setDataFromFile(ByteArrayInputStream data) {
	// here is no action performed in test module
	}

	@Override
	public ByteArrayOutputStream getDataForFile() {
		return null;
	}

	@Override
	public void print() {
	// here is no action performed in test module
	}
}
\end{lstlisting}

\subsection{IModuleInfo}
The class which implements this interface provides some basic information
about the module. The class yields the name, version, author(s), license,
description and a logo. Furthermore it holds the information about open files.

\begin{lstlisting}[frame=single,caption={IModuleInfo interface}]
public interface IModuleInfo {

	/**
	 * Retrieves the name of the module, which is shown on a module chooser
	 * dialog, on the tab of the module and as the menu-name of the module menu.
	 * 
	 * @return the name of the module
	 */
	public String getName();

	/**
	 * Retrieves the current build version number of the module as string.
	 * 
	 * @return the version number of the module
	 */ 
	public String getVersion();

	/**
	 * Retrieves a comma-separated list of the authors of the module.
	 * 
	 * @return tha author(s) of the module
	 */
	public String getAuthor();

	/**
	 * Retrieves a (more or less) short description about the module. It is
	 * shown on the module chooser inter alia. So it should give a short, but
	 * detailled information about the module.
	 * 
	 * @return a string representing a description of the module
	 */
	public String getDescription();

	/**
	 * Retrieves an <code>URL</code> object pointing to the logo image of the
	 * module. The image has to be sized to 16 x 16 pixels. It is shown on the
	 * tab of the module and in the new-Menu. Also this logo image is shown on
	 * the module chooser dialog, but later versions may provide two icons, one
	 * small icon for menu and tab and a big icon for the module chooser dialog. 
	 * 
	 * @return an <code>URL</code> to the logo of the module
	 */
	public URL getLogoURL();

	/**
	 * Retrieves a string describing the license, the module is distributed with.
	 * 
	 * @return the license
	 */
	public String getLicense();
	
	/**
	 * Retrieves an <code>URL</code> object pointing to the HelpSet file of the module.  
	 * The HelpSet file is the major metafile of the JavaHelp system.
	 * The URL must point to a *.hs-file.
	 * 
	 * @return the HelpSet filename
	 */
	public URL getHelpSetURL();
}
\end{lstlisting}

\subsection{ModuleInfo from testModule}
Here is a concrete example for a class implementing the \code{IModuleInfo} interface.

\begin{lstlisting}[frame=single,caption={Sample ModuleInfo Code}]
public class ModuleInfo
implements IModuleInfo {

	/** The singleton instance */
	private static IModuleInfo instance;

	/**
	 * The only constructor is unusable from outside this class. This is part of
	 * the singleton design pattern.
	 */
	private ModuleInfo() {
	// unusable from outside
	}

	/**
	 * Retrieves the singleton instance of <code>IModuleInfo</code>.
	 * 
	 * @return the singleton instance
	 */
	public static IModuleInfo getInstance() {
		if (instance == null) instance = new ModuleInfo();
		return instance;
	}

	public String getName() {
		return "TestModule";
	}

	public String getVersion() {
		return "2.0";
	}

	public String getAuthor() {
		return "The author";
	}

	public String getDescription() {
		return "A module for testing purposes. It shows simply, how to create "
			+ "a module";
	}

	public URL getLogoURL() {
		return Messages.getResourceURL("main", "ui.Logo_small");
	}

	public String getLicense() {
		return "GPL";
	}
	
	public URL getHelpSetURL(){
		return null;
	}
}
\end{lstlisting}

If this is too easy for you, just have a look at the existing modules, namely
"AVL-trees", "Dijkstra-algorithm", "Syntax diagrams and EBNF".
\newpage

\section{Bind the module to the main program}
Binding a new module to the main program is really easy: You only have to add
the jar file of your module to the directory \url{runtime/modules}. This can be done
automatically by using Ant (\url{http://ant.apache.org/}).

\emph{TODO:} more detailed description

\section{Known bugs}
\begin{itemize}
\item The method \code{public void print()} is unused and senseless at the moment.
\end{itemize}

\section{Reporting bugs}
If you find a bug please be so kind to drop us an email (\url{j-algo-development@lists.sourceforge.net}).

\section{See also}\label{seealso}
To program a module you need information about Swing. This can be found at \url{http://java.sun.com/products/jfc/}.

More detailed information can be found in the source code.

\end{document}
